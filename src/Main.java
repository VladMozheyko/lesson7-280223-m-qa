public class Main {
    /*
    План занятия
    1) Интерфейсы
    2) Структуры данных
    3) ArrayList и LinkedList
     */

    /*
    Теория
    Существует программирование по контракту - т.е. при создании класса который будет выступать родителем для других
    классов в него добавляют абстрактные методы(методы без реализации) таким образом программист обязывает любой класс,
    который унаследует этот класс реализовать свою версию всех абстрактных методов(создается контракт)

    В Java для программирования по контракту существует 2 вида классов: абстрактные классы, интерфейсы
    1) Абстрактный класс содержит абстрактные методы и обычные
    2) Интерфейс содержит только абстрактные методы

    Множественное наследование в Java реализовано через интерфейсы, т.е. при реализаци наследования класс явно определяет
    свою версию методов интерфейса, таким образом в случае возникновения конфликта(дублирования методов с одним названием)
    компилятор будет знать, какой метод ему вызвать - ведь в классе будет конкретная реализация по контракту

    Чтобы унаследоваться от интерфейса, мы указываем слово implements и далее через запятую указываем интерфейсы, которые
    реализуем:

    public class Car extends Machine implements Driveable, RudderListener{

    }

    Класс Car наследует класс Machine и реализует  интерфейсы: Driveable и RudderListener

    По названиям можно предположить, что Driveable поставляет методы для действия автомобиля(движения), а
    RudderListener методы для прослушивания действий руля




     */

    /*
    Заметки

    При работе с методами существует два понятия:
    1) Перегрузка - инструмент полиморфизма, который позволяет создавать методы с одинаковым названием, но разным набором
    параметров. Чаще всего используется для конструкторов объектов
    Полиморфизм(многоформие) - один из основных принципов ООП предназначеный для решения подобных задач
    2) Переопределение - изменение функционала метода в классе потомке. Чтобы переопределить метод в классе потомке достаточно
    указать метод с таким же названием и в теле метода указать свою реализацию. Аннотация Override указывает, что метод
    переопределен и проверяет наличие такого метода в классе родители. Можно переопределить метод и без этой аннотации,
    т.к. на исполнение программы она не влияет, в отличие от некоторых других аннотаций

     */

    public static void main(String[] args) {
        /*
        Задача создать интерфейс, который будет поставлять методы для передвижения.
        Сделать классы: Human, Snake, Fish, которые будут им пользоваться(передвигаться)

        Решение
        Создаем интерфейс Walkable и определяем в нем метод walk, создаем классы, которые его реализуют
         */
        // Создаем объекты классов, которые реализовали один интерфейс(подписали контракт) и каждый из них представил свою реализацию метода интерфейса
         Human human = new Human("Masha");
         Snake snake = new Snake("Snake Igor");

         human.walk();
         snake.walk();

         Fish fish = new Fish("Nemo");
         fish.walk();

         // Пример полиморфизма - конструктор класса Human перегружен(см. класс), таким образом можно создавать разные версии этого объекта
         Human nastya = new Human("Nastya", "Teacher");

        /*
        Задача
        Существует класс Body,  в котором есть методы parts, eyes

        Нужно добавить в систему функционал этого класса
        Решение
        Создадим класс Body и унаследуемся от него

        У человека есть руки и ноги, у змеи только туловище, а у рыбы плавники.
        Попробует переопределить метод part для каждого класса, поскольку переопределение метода добровольное действие программист
        может забыть это сделать. Как проектировщики системы заставим пользователя(потомка, клиента) нашего класса переопределить
        метод parts - составим контракт на использование нашего класса Body - сделаем его абстрактным и метод parts
        сделаем абстрактным

        А глаза есть у всех животных, которых мы запрограммировали, поэтому этот метод оставим обычным и будем использовать
        его при наследовании

        Добавим класс Worm. У червей нет глаз, поэтому просто переопределим метод eyes в классе Worm и оставим его пустым
         */
        human.parts();
        human.eyes();

        fish.parts();
        fish.eyes();

        snake.parts();
        snake.eyes();

        Worm worm = new Worm("Worm Kostya");
        worm.parts();
        worm.walk();
        worm.eyes();




    }

    /*
    ДЗ
    1*) Разобрать паттерн "Стратегия"
     */
}
